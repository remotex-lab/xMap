/**
 * Import will remove at compile time
 */

import type {
    MappingInterface,
    PositionInterface,
    SourceMapInterface,
    ShiftSegmentInterface,
    SourceOptionsInterface,
    PositionSourceInterface,
    ThresholdSegmentInterface
} from '@services/interfaces/source.interface';

/**
 * Imports
 */

import { Bias } from '@services/interfaces/source.interface';
import { decodeVLQ, encodeArrayVLQ } from '@components/base64.component';

/**
 * A service for validating and processing source maps.
 */

export class SourceService {
    /**
     * A list of symbol names used by the “mappings” entry.
     */

    private readonly names: Array<string>;

    /**
     * An array of source file paths.
     */

    private readonly sources: Array<string>;

    /**
     * A string of base64 VLQ-encoded mappings.
     */

    private readonly mappings: Array<MappingInterface>;

    /**
     * An array of source files contents.
     */

    private readonly sourcesContent: Array<string>;

    /**
     * Creates a new SourceService instance.
     *
     * @param source - The source map object to be validated.
     * @throws Error If any required key is missing from the source map.
     */

    constructor(source: SourceMapInterface) {
        this.validateSourceMap(source);

        this.names = source.names ?? [];
        this.sources = source.sources ?? [];
        this.mappings = [];
        this.sourcesContent = source.sourcesContent ?? [];
        this.decodeMappings(source);
    }

    /**
     * Returns a plain object representation of the source map data.
     *
     * This method creates a new object containing essential source map properties:
     * - `version`: The version of the source map (typically 3).
     * - `names`: An array of function or variable names from the original source code.
     * - `sources`: An array of source file names referenced in the mappings.
     * - `mappings`: A string representation of the encoded source map mappings. (Generated by `encodeMappings`)
     * - `sourcesContent`: An optional array containing the content of the source files. (May not be present in all source maps)
     *
     * @returns A plain object representing the source map data.
     */

    getMapObject(): SourceMapInterface {
        return {
            version: 3,
            names: this.names,
            sources: this.sources,
            mappings: this.encodeMappings(this.mappings),
            sourcesContent: this.sourcesContent
        };
    }

    /**
     * Retrieves source code information for a given line and column in the generated code.
     *
     * @param line - The line number in the generated code.
     * @param column - The column number in the generated code.
     * @param options - Optional configuration for retrieving source information.
     *   linesBefore (default: 3) - Number of lines before the matching source line to include.
     *   linesAfter (default: 4) - Number of lines after the matching source line to include.
     *   includeSourceContent (default: false) - Flag to include the relevant source code snippet.
     * @returns An object containing source location information (line, column, name, source)
     *         or including source code (code) if the includeSourceContent flag is set.
     *         Returns null if no matching mapping is found.
     */

    getSourcePosition(line: number, column: number, options?: SourceOptionsInterface): PositionSourceInterface | null {
        const settings = Object.assign({
            bias: Bias.LOWER_BOUND,
            linesAfter: 4,
            linesBefore: 3
        }, options);

        const map = this.findMapping(line, column, settings.bias);
        if (!map || isNaN(map.fileIndex)) {
            return null;
        }

        const code = this.sourcesContent[map.fileIndex].split('\n');
        const endLine = (map.sourceLine ?? 1) + settings.linesAfter;
        const startLine = Math.max((map.sourceLine ?? 1) - settings.linesBefore, 0);
        const relevantCode = code.slice(startLine, Math.min(endLine + 1, code.length)).join('\n');

        return {
            code: relevantCode,
            line: map.sourceLine,
            column: map.sourceColumn,
            endLine: endLine,
            startLine: startLine,
            name:this.names[map.nameIndex ?? -1] ?? null,
            source: this.sources[map.fileIndex]
        };
    }

    /**
     * Retrieves the position information in the original source code for a given line and column in the generated code.
     *
     * @param line - The line number in the generated code.
     * @param column - The column number in the generated code.
     * @param bias - An optional bias value specifying how to handle cases where only the line number matches. Defaults to Bias.LOWER_BOUND.
     *               Bias.LOWER_BOUND: If the line number matches but the column is less, return the closest mapping with a lower column.
     *               Bias.UPPER_BOUND: If the line number matches but the column is greater, return the closest mapping with a higher column.
     *               Bias.BOUND: If the line number matches and the column doesn't, return null (default behavior).
     * @returns A PositionInterface object representing the position in the original source code, or null if no matching position is found.
     */

    getPosition(line: number, column: number, bias: Bias = Bias.LOWER_BOUND): PositionInterface | null {
        const map = this.findMapping(line, column, bias);
        if (!map) {
            return map;
        }

        return {
            line: map.sourceLine,
            column: map.sourceColumn,
            name: this.names[map.nameIndex ?? -1] ?? null,
            source: this.sources[map.fileIndex]
        };
    }

    /**
     * Merges multiple source maps into this source map object.
     * The order of the provided source maps must match the order in which the corresponding source files were concatenated.
     *
     * @param maps - An array of `SourceService` instances representing the source maps to be merged.
     * @throws Error - If no source maps are provided for concatenation.
     */

    concat(...maps: Array<SourceMapInterface>): void {
        if (maps.length < 1) {
            throw new Error('At least one map must be provided for concatenation.');
        }

        for (const map of maps) {
            this.names.push(...map.names);
            this.sources.push(...map.sources);
            this.sourcesContent.push(...map.sourcesContent);

            const lastSegment = this.mappings[this.mappings.length - 1];
            const lines = this.sourcesContent[lastSegment.fileIndex].split('\n').length;

            this.decodeMappings(maps[0], {
                nameIndex: this.names.length - 1,
                fileIndex: this.sources.length - 1,
                generatedLine: lines < 2 ? 2 : lines
            });
        }
    }

    /**
     * Converts the source map object to a base64 encoded string representation.
     *
     * This method performs the following steps:
     * 1. Creates a plain object representation of the source map using `getMapObject`.
     * 2. Convert the plain object to a JSON string using `JSON.stringify`.
     * 3. Encodes the JSON string using the `encode` function (assumed to be a base64 encoding function).
     *
     * @returns A string representing the source map.
     */

    toString(): string {
        return JSON.stringify(this.getMapObject());
    }

    /**
     * Validates the provided source map object.
     *
     * This private method throws an error if any of the required keys are missing from the source map.
     *
     * @private
     * @param input - The source map object to be validated.
     * @throws Error If any required key is missing from the source map.
     */

    private validateSourceMap(input: SourceMapInterface): void {
        const requiredKeys: (keyof SourceMapInterface)[] = [ 'version', 'sources', 'sourcesContent', 'mappings', 'names' ];
        if (!requiredKeys.every(key => key in input)) {
            throw new Error('Missing required keys in SourceMap.');
        }
    }

    /**
     * Decodes and processes the encoded mappings.
     *
     *  @param encodedMappings - The source map object to be decoded.
     * @param thresholdSegment
     */

    private decodeMappings(encodedMappings: SourceMapInterface, thresholdSegment?: ThresholdSegmentInterface): void {
        // Note: Line and column numbers in source maps start at 1,
        // unlike arrays which start at 0. Therefore, the initial shift for lines is set to 1.
        const shift = Object.assign({
            fileIndex: 0,
            nameIndex: 0,
            sourceLine: 1,
            sourceColumn: 1,
            generatedLine: 1,
            generatedColumn: 1
        }, thresholdSegment);

        try {
            for (const [ generatedLine, stringSegments ] of encodedMappings.mappings.split(';').entries()) {
                if (!stringSegments) continue;
                shift.generatedColumn = 1;
                const segments = stringSegments.split(',');

                for (const segment of segments) {
                    if (segment.length < 4) continue;
                    const decodedSegment = decodeVLQ(segment);

                    this.decodedSegment(shift, decodedSegment, generatedLine + shift.generatedLine);
                }
            }
        } catch (error) {
            throw new Error(`Error decoding mappings: ${ (<Error>error).message }`);
        }
    }

    /**
     * Processes a decoded segment and updates the mappings.
     *
     * @param shift - The current state of the mapping information.
     * @param decodedSegment - The decoded VLQ segment.
     * @param generatedLine - The current line index in the generated code.
     */

    private decodedSegment(shift: ShiftSegmentInterface, decodedSegment: Array<number>, generatedLine: number): void {
        const [ generatedColumn, fileIndex, sourceLine, sourceColumn, nameIndex ] = decodedSegment;
        shift.fileIndex += fileIndex;
        shift.nameIndex += nameIndex ?? 0;
        shift.sourceLine += sourceLine;
        shift.sourceColumn += sourceColumn;
        shift.generatedColumn += generatedColumn;

        this.mappings.push({
            nameIndex: (nameIndex !== undefined) ? shift.nameIndex : null,
            fileIndex: shift.fileIndex,
            sourceLine: shift.sourceLine,
            sourceColumn: shift.sourceColumn,
            generatedLine: generatedLine,
            generatedColumn: shift.generatedColumn
        });
    }

    /**
     * Encodes the mappings into a VLQ string.
     *
     * @param mappings - An array of MappingInterface objects to encode.
     * @returns A VLQ-encoded string representing the mappings.
     */

    private encodeMappings(mappings: Array<MappingInterface>): string {
        let resultMapping = '';
        let segments: Array<string> = [];

        const shift = {
            fileIndex: 0,
            nameIndex: 0,
            sourceLine: 1,
            sourceColumn: 1,
            generatedLine: 1,
            generatedColumn: 1
        };

        shift.generatedLine = mappings[0].generatedLine;
        resultMapping += ';'.repeat(shift.generatedLine - 1);

        for (const map of mappings) {
            if (map.generatedLine !== shift.generatedLine) {
                resultMapping += segments.join(',');
                resultMapping += ';'.repeat(Math.max(1, map.generatedLine - shift.generatedLine));

                segments = [];
                shift.generatedLine = map.generatedLine;
                shift.generatedColumn = 1;
            }

            this.encodeSegment(map, segments, shift);
        }

        return resultMapping + segments.join(',') + ';';
    }

    /**
     * Encodes a single segment of the mappings.
     *
     * @param map - The MappingInterface object representing a single mapping.
     * @param segments - An array of encoded segments.
     * @param shift - The current state of the mapping information.
     */

    private encodeSegment(map: MappingInterface, segments: Array<string>, shift: ShiftSegmentInterface): void {
        const segment: Array<number> = [];
        const sourceIndex = map.fileIndex;

        segment[1] = 0;
        segment[2] = map.sourceLine - shift.sourceLine;
        segment[3] = map.sourceColumn - shift.sourceColumn;
        segment[0] = map.generatedColumn - shift.generatedColumn;

        if (sourceIndex !== shift.fileIndex) {
            segment[1] = sourceIndex - shift.fileIndex;
            shift.fileIndex = sourceIndex;
        }

        if (map.nameIndex) {
            const nameIndex = map.nameIndex;
            segment[4] = nameIndex - shift.nameIndex;
            shift.nameIndex = nameIndex;
        }

        shift.sourceLine = map.sourceLine;
        shift.sourceColumn = map.sourceColumn;
        shift.generatedColumn = map.generatedColumn;
        segments.push(encodeArrayVLQ(segment));
    }

    /**
     * Performs a binary search on the internal `mappings` array to find a mapping object based on the line and column information.
     * This function utilizes a binary search algorithm to efficiently locate the mapping corresponding to a specific line and column in the generated code.
     *
     * @param targetLine - The line number in the generated code to search for.
     * @param targetColumn - The column number in the generated code to search for.
     * @param bias - An optional bias value specifying how to handle cases where only the line number matches (DEFAULT: Bias.BOUND).
     *                 Bias.LOWER_BOUND: If the line number matches but the column is less, return the closest mapping with a lower column.
     *                 Bias.UPPER_BOUND: If the line number matches but the column is greater, return the closest mapping with a higher column.
     *                 Bias.BOUND: If the line number matches and the column doesn't, return null (default behavior).
     * @returns A MappingInterface object representing the found mapping, or null if no matching mapping is found based on the bias.
     */

    private findMapping(targetLine: number, targetColumn: number, bias: Bias = Bias.BOUND): MappingInterface | null {
        let startIndex = 0;
        let endIndex = this.mappings.length - 1;
        let closestMapping: MappingInterface | null = null;

        while (startIndex <= endIndex) {
            const middleIndex = Math.floor((startIndex + endIndex) / 2);
            const currentMapping = this.mappings[middleIndex];

            if (currentMapping.generatedLine < targetLine) {
                startIndex = middleIndex + 1;
            } else if (currentMapping.generatedLine > targetLine) {
                endIndex = middleIndex - 1;
            } else {
                // The line matches, now we handle the column bias
                if (currentMapping.generatedColumn < targetColumn) {
                    startIndex = middleIndex + 1;
                    if (bias === Bias.LOWER_BOUND) {
                        closestMapping = currentMapping;
                    }
                } else if (currentMapping.generatedColumn > targetColumn) {
                    endIndex = middleIndex - 1;
                    if (bias === Bias.UPPER_BOUND) {
                        closestMapping = currentMapping;
                    }
                } else {
                    return currentMapping;
                }
            }
        }

        // If the line doesn't match any mapping, return null
        return closestMapping && closestMapping.generatedLine === targetLine ? closestMapping : null;
    }
}
